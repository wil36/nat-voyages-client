# üîê Am√©liorations de S√©curit√© - NAT Voyages

## ‚ö†Ô∏è Probl√®mes Identifi√©s

### 1. Rate Limiting (Limitation de d√©bit)
**Probl√®me** : Aucune protection contre les attaques par force brute ou spam de r√©servations.

### 2. Gestion d'erreurs des transactions
**Probl√®me** : La transaction Firestore manque de gestion d'erreurs robuste et de logs.

---

## ‚úÖ Solutions Propos√©es

### SOLUTION 1: Rate Limiting c√¥t√© client

Cr√©er un hook personnalis√© pour limiter les r√©servations.

#### √âtape 1: Cr√©er le fichier `src/hooks/useRateLimit.js`

```javascript
import { useState, useEffect } from 'react';

/**
 * Hook pour impl√©menter un rate limiting c√¥t√© client
 * @param {number} maxAttempts - Nombre maximum de tentatives
 * @param {number} windowMs - Fen√™tre de temps en millisecondes
 * @returns {Object} { canProceed, remainingAttempts, resetTime, recordAttempt }
 */
export const useRateLimit = (maxAttempts = 3, windowMs = 60000) => {
  const [attempts, setAttempts] = useState([]);

  useEffect(() => {
    // Nettoyer les anciennes tentatives toutes les secondes
    const interval = setInterval(() => {
      const now = Date.now();
      setAttempts(prev => prev.filter(timestamp => now - timestamp < windowMs));
    }, 1000);

    return () => clearInterval(interval);
  }, [windowMs]);

  const canProceed = () => {
    const now = Date.now();
    const recentAttempts = attempts.filter(timestamp => now - timestamp < windowMs);
    return recentAttempts.length < maxAttempts;
  };

  const recordAttempt = () => {
    setAttempts(prev => [...prev, Date.now()]);
  };

  const remainingAttempts = () => {
    const now = Date.now();
    const recentAttempts = attempts.filter(timestamp => now - timestamp < windowMs);
    return Math.max(0, maxAttempts - recentAttempts.length);
  };

  const getResetTime = () => {
    if (attempts.length === 0) return null;
    const oldestAttempt = Math.min(...attempts);
    return new Date(oldestAttempt + windowMs);
  };

  return {
    canProceed: canProceed(),
    remainingAttempts: remainingAttempts(),
    resetTime: getResetTime(),
    recordAttempt,
  };
};
```

#### √âtape 2: Utiliser le hook dans DetailVoyage.js

```javascript
// Ajouter en haut du composant
import { useRateLimit } from '../hooks/useRateLimit';

// Dans le composant DetailVoyage
export default function DetailVoyage() {
  // Rate limiting: 5 tentatives max par minute
  const rateLimit = useRateLimit(5, 60000);

  const handleTicketSubmit = async (e) => {
    e.preventDefault();

    // V√âRIFICATION RATE LIMIT
    if (!rateLimit.canProceed) {
      const resetTime = rateLimit.resetTime;
      const minutesLeft = Math.ceil((resetTime - new Date()) / 60000);

      alert(
        `‚ö†Ô∏è Trop de tentatives de r√©servation.\n` +
        `Veuillez patienter ${minutesLeft} minute(s) avant de r√©essayer.\n` +
        `Ceci est une mesure de s√©curit√© pour √©viter les abus.`
      );
      return;
    }

    // Validation avant soumission
    if (!validateForm()) {
      return;
    }

    setIsSubmitting(true);

    try {
      // Enregistrer la tentative
      rateLimit.recordAttempt();

      // V√©rifier la disponibilit√© des places en temps r√©el
      const { voyageData, placesNecessaires } = await verifierDisponibilite();

      // ... reste du code de transaction
    } catch (error) {
      console.error("Erreur lors de l'enregistrement:", error);

      // NE PAS enregistrer comme tentative si erreur de validation
      // (seulement pour les vraies tentatives de soumission)

      alert(`Erreur lors de l'enregistrement des billets: ${error.message}`);
    } finally {
      setIsSubmitting(false);
    }
  };
}
```

---

### SOLUTION 2: Am√©liorer la gestion d'erreurs des transactions

#### Cr√©er un utilitaire de gestion d'erreurs robuste

Fichier: `src/utils/transactionHelpers.js`

```javascript
/**
 * Cat√©gories d'erreurs pour un meilleur traitement
 */
export const ErrorCategories = {
  VALIDATION: 'VALIDATION',
  AVAILABILITY: 'AVAILABILITY',
  NETWORK: 'NETWORK',
  TRANSACTION: 'TRANSACTION',
  UNKNOWN: 'UNKNOWN',
};

/**
 * Classe d'erreur personnalis√©e pour les r√©servations
 */
export class ReservationError extends Error {
  constructor(message, category = ErrorCategories.UNKNOWN, details = {}) {
    super(message);
    this.name = 'ReservationError';
    this.category = category;
    this.details = details;
    this.timestamp = new Date();
  }

  getUserMessage() {
    const messages = {
      [ErrorCategories.VALIDATION]: '‚ùå Erreur de validation: ' + this.message,
      [ErrorCategories.AVAILABILITY]: '‚ö†Ô∏è Disponibilit√©: ' + this.message,
      [ErrorCategories.NETWORK]: 'üåê Probl√®me de connexion: Veuillez v√©rifier votre connexion internet.',
      [ErrorCategories.TRANSACTION]: 'üíæ Erreur lors de l\'enregistrement: ' + this.message,
      [ErrorCategories.UNKNOWN]: '‚ö†Ô∏è Une erreur inattendue s\'est produite. Veuillez r√©essayer.',
    };

    return messages[this.category] || this.message;
  }

  shouldRetry() {
    return this.category === ErrorCategories.NETWORK ||
           this.category === ErrorCategories.TRANSACTION;
  }

  log() {
    console.error('[ReservationError]', {
      category: this.category,
      message: this.message,
      details: this.details,
      timestamp: this.timestamp,
      stack: this.stack,
    });
  }
}

/**
 * Logger de transactions pour audit
 */
export class TransactionLogger {
  static logs = [];

  static log(action, data, status = 'INFO') {
    const entry = {
      timestamp: new Date().toISOString(),
      action,
      status,
      data,
    };

    this.logs.push(entry);
    console.log(`[Transaction ${status}]`, action, data);

    // Limiter √† 100 logs en m√©moire
    if (this.logs.length > 100) {
      this.logs = this.logs.slice(-100);
    }

    return entry;
  }

  static success(action, data) {
    return this.log(action, data, 'SUCCESS');
  }

  static error(action, error) {
    return this.log(action, { error: error.message, stack: error.stack }, 'ERROR');
  }

  static warning(action, data) {
    return this.log(action, data, 'WARNING');
  }

  static getLogs() {
    return this.logs;
  }

  static clearLogs() {
    this.logs = [];
  }
}

/**
 * Wrapper pour les transactions Firestore avec retry automatique
 */
export async function executeTransactionWithRetry(
  db,
  transactionFn,
  maxRetries = 3,
  retryDelay = 1000
) {
  let lastError;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      TransactionLogger.log('TRANSACTION_ATTEMPT', { attempt, maxRetries });

      const result = await runTransaction(db, transactionFn);

      TransactionLogger.success('TRANSACTION_COMPLETE', { attempt });
      return result;

    } catch (error) {
      lastError = error;
      TransactionLogger.error('TRANSACTION_FAILED', error);

      // Ne pas r√©essayer si c'est une erreur de validation
      if (error.code === 'permission-denied' ||
          error.code === 'invalid-argument' ||
          error.message.includes('Plus assez de places')) {
        throw new ReservationError(
          error.message,
          ErrorCategories.AVAILABILITY,
          { originalError: error }
        );
      }

      // R√©essayer pour les erreurs r√©seau/serveur
      if (attempt < maxRetries) {
        TransactionLogger.warning('TRANSACTION_RETRY', {
          attempt,
          nextAttemptIn: retryDelay
        });

        await new Promise(resolve => setTimeout(resolve, retryDelay * attempt));
      }
    }
  }

  // Toutes les tentatives ont √©chou√©
  throw new ReservationError(
    'Impossible de finaliser la r√©servation apr√®s plusieurs tentatives',
    ErrorCategories.TRANSACTION,
    { originalError: lastError, attempts: maxRetries }
  );
}
```

#### Appliquer dans DetailVoyage.js

```javascript
import {
  ReservationError,
  ErrorCategories,
  TransactionLogger,
  executeTransactionWithRetry
} from '../utils/transactionHelpers';

// Dans handleTicketSubmit
const handleTicketSubmit = async (e) => {
  e.preventDefault();

  // Validation et rate limiting...

  setIsSubmitting(true);

  try {
    TransactionLogger.log('RESERVATION_START', {
      passagers: reservationForm.passagers.length,
      typeVoyage: reservationForm.type_voyage,
    });

    // V√©rifier la disponibilit√©
    const { voyageData, placesNecessaires } = await verifierDisponibilite();

    TransactionLogger.success('AVAILABILITY_CHECK', { placesNecessaires });

    // Pr√©-traitement des clients...
    const clientsData = await prepareClientsData();

    // Ex√©cuter la transaction avec retry automatique
    const result = await executeTransactionWithRetry(
      db,
      async (transaction) => {
        return await performReservationTransaction(
          transaction,
          voyageData,
          placesNecessaires,
          clientsData
        );
      },
      3, // 3 tentatives max
      1000 // 1 seconde entre chaque tentative
    );

    TransactionLogger.success('RESERVATION_COMPLETE', {
      ventesCount: result.ventes.length,
      montantTotal,
    });

    // G√©n√©rer les billets PDF
    await genererFactureMultiPassagers(result.ventes);

    // R√©initialiser le formulaire...
    resetForm();

    // Message de succ√®s
    alert(
      `‚úÖ R√©servation r√©ussie!\n\n` +
      `${result.ventes.length} billet(s) r√©serv√©(s)\n` +
      `Montant total: ${montantTotal.toLocaleString()} FCFA\n\n` +
      `Les billets s'ouvrent dans une nouvelle fen√™tre.`
    );

  } catch (error) {
    // Gestion d'erreur am√©lior√©e
    if (error instanceof ReservationError) {
      error.log();

      // Message utilisateur personnalis√© selon le type d'erreur
      alert(error.getUserMessage());

      // Si l'erreur peut √™tre r√©essay√©e, proposer de r√©essayer
      if (error.shouldRetry()) {
        const retry = confirm(
          'Voulez-vous r√©essayer la r√©servation?\n\n' +
          'Cela peut r√©soudre les probl√®mes temporaires de connexion.'
        );

        if (retry) {
          // Relancer la soumission
          setTimeout(() => handleTicketSubmit(e), 500);
        }
      }
    } else {
      // Erreur non cat√©goris√©e
      console.error("Erreur inattendue:", error);
      TransactionLogger.error('UNKNOWN_ERROR', error);

      alert(
        '‚ö†Ô∏è Une erreur inattendue s\'est produite.\n\n' +
        'D√©tails: ' + error.message + '\n\n' +
        'Veuillez r√©essayer ou contacter le support si le probl√®me persiste.'
      );
    }
  } finally {
    setIsSubmitting(false);
  }
};
```

---

### SOLUTION 3: Rate Limiting c√¥t√© serveur (Recommand√©)

Pour une s√©curit√© maximale, impl√©menter √©galement un rate limiting c√¥t√© serveur avec Cloud Functions.

Fichier: `functions/src/rateLimiter.js` (n√©cessite Firebase Functions)

```javascript
const admin = require('firebase-admin');

/**
 * Rate limiter bas√© sur l'IP et l'ID utilisateur
 */
class RateLimiter {
  constructor(maxAttempts = 10, windowMs = 60000) {
    this.maxAttempts = maxAttempts;
    this.windowMs = windowMs;
    this.attempts = new Map();
  }

  getKey(ip, userId = 'anonymous') {
    return `${ip}_${userId}`;
  }

  async checkLimit(ip, userId) {
    const key = this.getKey(ip, userId);
    const now = Date.now();

    // Nettoyer les anciennes tentatives
    if (this.attempts.has(key)) {
      const userAttempts = this.attempts.get(key);
      const validAttempts = userAttempts.filter(
        timestamp => now - timestamp < this.windowMs
      );
      this.attempts.set(key, validAttempts);
    }

    const attempts = this.attempts.get(key) || [];

    if (attempts.length >= this.maxAttempts) {
      const oldestAttempt = Math.min(...attempts);
      const resetTime = new Date(oldestAttempt + this.windowMs);

      throw new Error(
        `Trop de tentatives. R√©essayez apr√®s ${resetTime.toLocaleTimeString()}`
      );
    }

    return true;
  }

  recordAttempt(ip, userId) {
    const key = this.getKey(ip, userId);
    const attempts = this.attempts.get(key) || [];
    attempts.push(Date.now());
    this.attempts.set(key, attempts);
  }
}

module.exports = { RateLimiter };
```

---

## üìä R√©sum√© des am√©liorations

| Am√©lioration | Priorit√© | Complexit√© | Impact |
|--------------|----------|------------|--------|
| Rate Limiting client | üî¥ Haute | Faible | Emp√™che les abus basiques |
| Gestion d'erreurs am√©lior√©e | üî¥ Haute | Moyenne | Meilleure UX et debugging |
| Transaction logging | üü° Moyenne | Faible | Audit et tra√ßabilit√© |
| Rate Limiting serveur | üü¢ Recommand√© | Moyenne | Protection maximale |

---

## üöÄ Ordre d'impl√©mentation recommand√©

1. ‚úÖ **Gestion d'erreurs am√©lior√©e** (1h)
2. ‚úÖ **Rate Limiting c√¥t√© client** (30 min)
3. ‚úÖ **Transaction logging** (30 min)
4. üîú **Rate Limiting serveur** (2h, n√©cessite Cloud Functions)

---

## üìù Notes importantes

- Le rate limiting c√¥t√© client est facilement contournable mais d√©courage les utilisateurs normaux
- Le rate limiting c√¥t√© serveur est la vraie protection (n√©cessite Firebase Functions payantes)
- Combinez les deux approches pour une protection optimale
- Gardez des logs d√©taill√©s pour identifier les comportements suspects

